# フロントエンドとバックエンドの分離に関する実装方針 [完了]

## 概要

現在のTodoLogアプリケーションは、Electron/Node.js環境での実行を前提としており、ブラウザ環境では動作しません。フロントエンドとバックエンドを分離することで、ブラウザ環境でも動作するようにし、ファイルシステムへのアクセスはバックエンドが担当するアーキテクチャに変更します。

## 実装状況

**ステータス: 完了 (2025-04-18)**

- [x] プロジェクト構造の再編成
  - [x] client/server ディレクトリの作成
  - [x] 既存コードのclientへの移動
  - [x] 不要なルートディレクトリのsrcを削除

- [x] バックエンドの実装
  - [x] Express.jsプロジェクトのセットアップ
  - [x] APIエンドポイントの実装
  - [x] ファイル操作サービスの実装

- [x] フロントエンドの修正
  - [x] APIクライアントの実装
  - [x] カスタムフックの修正
  - [x] コンポーネントの接続

- [x] 開発環境の設定
  - [x] ルートpackage.jsonの設定
  - [x] client/serverそれぞれのpackage.jsonの設定

## 実装方針

### 1. アーキテクチャの変更

#### 現在のアーキテクチャ
- 単一のReactアプリケーション
- Node.jsのfs/promises APIを直接使用
- Electron/Node.js環境でのみ動作

#### 新しいアーキテクチャ
- **フロントエンド**: React + TypeScript (ブラウザで動作)
- **バックエンド**: Node.js + Express + TypeScript (サーバーサイド)
- **通信**: REST API または WebSocket

### 2. ディレクトリ構造

```
todolog/
├── client/             # フロントエンド
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/   # APIクライアント
│   │   ├── types/
│   │   └── ...
│   ├── package.json
│   └── ...
├── server/             # バックエンド
│   ├── src/
│   │   ├── controllers/
│   │   ├── models/
│   │   ├── routes/
│   │   ├── services/   # ファイル操作など
│   │   ├── types/
│   │   └── index.ts    # エントリーポイント
│   ├── package.json
│   └── ...
└── package.json        # ルートパッケージ（開発用）
```

### 3. バックエンド (server)

#### 技術スタック
- **ランタイム**: Node.js
- **フレームワーク**: Express
- **言語**: TypeScript
- **データ永続化**: ファイルシステム (fs/promises)

#### 主要コンポーネント
1. **APIサーバー**: Express.jsを使用したRESTful API
2. **コントローラー**: APIエンドポイントのロジック
3. **サービス**: ファイル操作などのビジネスロジック
4. **モデル**: データモデルとバリデーション

#### APIエンドポイント
- `GET /api/tasks` - タスク一覧の取得
- `GET /api/tasks/:id` - 特定のタスクの取得
- `POST /api/tasks` - 新しいタスクの作成
- `PUT /api/tasks/:id` - タスクの更新
- `DELETE /api/tasks/:id` - タスクの削除
- `PUT /api/tasks/:id/toggle` - タスクの完了状態の切り替え
- `PUT /api/tasks/:id/memo` - タスクのメモ更新
- `GET /api/categories` - カテゴリ一覧の取得

### 4. フロントエンド (client)

#### 技術スタック
- **ライブラリ**: React
- **言語**: TypeScript
- **ビルドツール**: Vite
- **状態管理**: React Query (データフェッチング用)

#### 主要コンポーネント
1. **APIクライアント**: バックエンドとの通信を担当
2. **コンポーネント**: 既存のUIコンポーネントを再利用
3. **カスタムフック**: データフェッチングと状態管理

#### 変更点
- `useTask` フックをAPI通信に対応するよう修正
- ファイル操作のロジックをAPIクライアントに置き換え
- オフライン対応のためのキャッシュ機能（オプション）

### 5. 認証とセキュリティ（オプション）

- 簡易的なユーザー認証
- CORS設定
- APIキーまたはJWTによる認証

### 6. 開発とデプロイ

#### 開発環境
- フロントエンドとバックエンドを別々に起動
- プロキシ設定によるローカル開発の簡素化

#### デプロイオプション
1. **セルフホスト**: 自前のサーバーにデプロイ
2. **クラウドサービス**: Vercel (フロントエンド) + Heroku/Railway (バックエンド)
3. **Docker**: コンテナ化してデプロイ

## 実装ステップ

1. **プロジェクト構造の再編成**
   - client/server ディレクトリの作成
   - 既存コードのclientへの移動

2. **バックエンドの実装**
   - Express.jsプロジェクトのセットアップ
   - APIエンドポイントの実装
   - ファイル操作サービスの実装

3. **フロントエンドの修正**
   - APIクライアントの実装
   - カスタムフックの修正
   - コンポーネントの接続

4. **テストとデバッグ**
   - バックエンドのユニットテスト
   - フロントエンドのユニットテスト
   - 統合テスト

5. **デプロイ準備**
   - 環境変数の設定
   - ビルドスクリプトの作成
   - デプロイドキュメントの作成

## メリット

1. **ブラウザ互換性**: 標準的なWebブラウザで動作
2. **拡張性**: バックエンドの機能を独立して拡張可能
3. **デプロイオプション**: 様々なホスティングオプションが利用可能
4. **セキュリティ**: ファイルシステムへの直接アクセスをバックエンドに限定
5. **スケーラビリティ**: 将来的なデータベース移行などが容易

## デメリット

1. **複雑性の増加**: 2つの独立したアプリケーションの管理
2. **開発環境**: セットアップがやや複雑に
3. **デプロイ**: 2つのアプリケーションのデプロイが必要
4. **ネットワーク依存**: オフライン動作には追加の対応が必要

## 次のステップ

1. バックエンドのプロジェクト構造とベースコードの作成
2. 基本的なAPIエンドポイントの実装
3. フロントエンドのAPIクライアント実装
4. 既存のコンポーネントとの接続
